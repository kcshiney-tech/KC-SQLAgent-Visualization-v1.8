<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>ECharts 多级 X 轴 — 全级显示 + 周颜色区分 + 周筛选</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <style>
    body { font-family: "Microsoft YaHei", Arial, sans-serif; margin: 12px; }
    #container { position: relative; width: 100%; max-width: 1200px; margin: 0 auto; }
    #main { width: 100%; height: 720px; border: 1px solid #eee; }
    .controls {
      position: absolute;
      right: 12px;
      top: 12px;
      background: rgba(255,255,255,0.98);
      border: 1px solid #ddd;
      padding: 8px 10px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.06);
      font-size: 13px;
      z-index: 1000;
      max-height: 340px;
      overflow: auto;
      min-width: 220px;
    }
    .controls h4 { margin: 0 0 6px 0; font-size: 13px; }
    .controls label { display: flex; align-items: center; gap:8px; margin: 6px 0; cursor: pointer; }
    .legend-color { width: 14px; height: 12px; border-radius: 2px; display:inline-block; vertical-align:middle; margin-right:6px; border:1px solid #ccc; }
    .controls .actions { margin-top: 6px; display:flex; gap:8px; }
    .note { margin-top:8px; color:#666; font-size:13px; }
  </style>
</head>
<body>
  <div id="container">
    <div id="main"></div>

    <div class="controls" id="controls">
      <h4>筛选显示的周 (Weeks) — 颜色即区分</h4>
      <div id="week-checkboxes"></div>
      <div class="actions">
        <button id="select-all">全选</button>
        <button id="clear-all">取消</button>
      </div>
      <div style="margin-top:8px;font-size:12px;color:#666">提示：轴上不再显示周文本，柱子颜色代表不同周。</div>
    </div>
  </div>

  <div class="note">
    说明：按 <code>.</code> 分层（不会把 ROCE 单独拆）。所有级别标签都会以跨列背景带显示；周用颜色区分并可筛选。
  </div>

<script>
(function(){
  // ---------------- 原始数据（可替换） ----------------
  const rawLabels = [
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-30",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-40",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-41",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-42",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-39",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-40",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-41",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-42",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-39",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-40",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-41",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-42",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-39",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-40",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-41",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-42",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-39",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-40",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-41",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-42",
    "ROCE-TOR下联-QYZNJ01.400G_AOC_QSFP112.Crealights.2025-41",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-39",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-40",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-42",
    "ROCE-TOR下联-QYZNJ01.AOC_QSFPDD.Crealights.2025-40"
  ];
  const rawValues = [0,0,2,0,1,1,0,0,0,3,0,0,7,0,0,0,4,1,1,1,1,2,3,1,1];

  // ---------------- 参数 ----------------
  const axisLabelFontSize = 13;
  const gapBetweenAxes = 30;
  const baseGrid = { left: 110, right: 40, top: 80, bottom: 24 };

  // ---------------- 辅助：拆层（仅按 '.' 分割） ----------------
  function splitIntoLayers(labels){
    const rows = labels.map(s => s.split('.'));
    const maxDepth = Math.max(...rows.map(r=>r.length));
    rows.forEach(r => { while (r.length < maxDepth) r.push(''); });
    const layers = [];
    for (let l=0; l<maxDepth; l++){
      layers.push(rows.map(r => r[l]));
    }
    return { rows, layers, maxDepth };
  }

  // ---------------- 辅助：compute groups ----------------
  function groupsFromArray(arr){
    const res = [];
    let i=0, n=arr.length;
    while (i<n){
      const v = arr[i];
      let j = i+1;
      while (j<n && arr[j] === v) j++;
      res.push({ start: i, end: j-1, label: v });
      i = j;
    }
    return res;
  }

  // ---------------- 计算 weeks 及颜色 ----------------  (palette can be extended)
  function computeWeeks(rows){
    const weeks = rows.map(r => r[r.length-1] || '');
    const uniq = Array.from(new Set(weeks));
    const palette = ['#5470c6','#91cc75','#fac858','#ee6666','#73c0de','#3ba272','#fc8452','#9a60b4','#ea7ccc','#5ab1ef','#9fb6ff'];
    const map = {};
    uniq.forEach((w,i) => map[w] = palette[i % palette.length]);
    return { weeks, uniq, map };
  }

  // ---------------- 初始化解析 ----------------
  let parsed = splitIntoLayers(rawLabels);
  let { rows, layers, maxDepth } = parsed;
  let groupsPerLevel = layers.map(l => groupsFromArray(l));
  let weekInfo = computeWeeks(rows);

  // ---------------- UI: week checkboxes & legend (右上) ----------------
  const controlsRoot = document.getElementById('week-checkboxes');
  function buildWeekControls(){
    controlsRoot.innerHTML = '';
    weekInfo.uniq.forEach(w => {
      const id = 'wk_' + w.replace(/[^\w]/g, '_');
      const label = document.createElement('label');
      const color = weekInfo.map[w];
      label.innerHTML = `<input type="checkbox" checked id="${id}" value="${w}" /><span class="legend-color" style="background:${color}"></span><span style="flex:1">${w}</span>`;
      controlsRoot.appendChild(label);
    });
  }
  buildWeekControls();
  document.getElementById('select-all').addEventListener('click', ()=>{ controlsRoot.querySelectorAll('input').forEach(cb=>cb.checked=true); applyFilterAndRender(); });
  document.getElementById('clear-all').addEventListener('click', ()=>{ controlsRoot.querySelectorAll('input').forEach(cb=>cb.checked=false); applyFilterAndRender(); });
  controlsRoot.addEventListener('change', applyFilterAndRender);

  // ---------------- chart init ----------------
  const chart = echarts.init(document.getElementById('main'));

  // ---------------- 核心：根据 week 选择构建并渲染图（通用，可复用） ----------------
  function applyFilterAndRender(){
    // get selected weeks
    const selectedWeeks = Array.from(controlsRoot.querySelectorAll('input[type=checkbox]')).filter(cb=>cb.checked).map(cb=>cb.value);
    // build indices of selected items
    const indices = rows.map((r,i)=> selectedWeeks.includes(r[r.length-1]) ? i : -1).map((v,i)=> v===-1? null : i).filter(i=>i!==null);

    if (indices.length === 0) {
      chart.clear();
      chart.setOption({ title: { text: '未选择任何周' } });
      return;
    }

    // filtered arrays
    const filteredLabels = indices.map(i => rawLabels[i]);
    const filteredRows = indices.map(i => rows[i].slice());
    const filteredValues = indices.map(i => rawValues[i]);
    // pad
    filteredRows.forEach(r => { while (r.length < maxDepth) r.push(''); });

    // filtered layers (same depth)
    const filteredLayers = [];
    for (let l=0; l<maxDepth; l++) filteredLayers.push(filteredRows.map(r=>r[l]));

    const filteredGroupsPerLevel = filteredLayers.map(arr => groupsFromArray(arr));

    // week mapping for filtered subset
    const filteredWeeks = filteredRows.map(r => r[r.length-1] || '');
    const seriesData = filteredValues.map((v,idx) => {
      const w = filteredWeeks[idx];
      return { value: v, itemStyle: { color: weekInfo.map[w] || '#5470c6' } };
    });

    // X axes: we want **倒序堆叠**：closest to bars is week (we hide week labels), farthest is top level
    // We'll create xAxis array where index 0 is bottom-most axis (week, hidden labels), index 1 is next, ..., last is topmost
    const xAxes = [];
    for (let level = maxDepth - 1; level >= 0; level--){
      const isWeekLevel = (level === maxDepth - 1);
      // decide whether to show axis labels: show for all levels EXCEPT week (as requested)
      const showLabel = !isWeekLevel;
      const axisData = showLabel ? filteredLayers[level] : new Array(filteredLabels.length).fill('');
      // compute offset stacking: bottom (week) offset 0, above layers offset gapBetweenAxes, etc.
      const idxFromBottom = (maxDepth - 1) - level; // 0..maxDepth-1
      const offset = idxFromBottom * gapBetweenAxes;
      xAxes.push({
        type: 'category',
        position: 'bottom',
        offset: offset,
        data: axisData,
        axisLine: { show: false },
        axisTick: { show: false },
        axisLabel: {
          interval: 0,
          rotate: 0,
          show: showLabel,
          color: '#222',
          fontSize: axisLabelFontSize,
          formatter: function(v) { return v; },
          align: 'center'
        },
        splitLine: { show: false },
        axisPointer: { show: false }
      });
    }

    // Build option
    const option = {
      title: { text: '2025年10月各集群AOC故障数（多级标签 & 周颜色）', left: 'center' },
      grid: { left: baseGrid.left, right: baseGrid.right, top: baseGrid.top, bottom: baseGrid.bottom + maxDepth * gapBetweenAxes },
      tooltip: {
        trigger: 'item',
        formatter: function(params){
          if (!params) return '';
          const idx = params.dataIndex;
          const val = params.value && params.value.value !== undefined ? params.value.value : params.value;
          const label = filteredLabels[idx];
          return `${label}<br/>故障数: <b>${val}</b>`;
        }
      },
      xAxis: xAxes,
      yAxis: { type: 'value', name: '故障数', nameLocation: 'end', nameGap: 18 },
      series: [{
        name: '故障数',
        type: 'bar',
        data: seriesData,
        xAxisIndex: 0, // bottom-most axis is index 0
        barMaxWidth: 28
      }],
      graphic: []
    };

    chart.setOption(option, { notMerge: true, lazyUpdate: false });

    // draw background bands for ALL levels except week (we still hide week labels but render bands for grouping)
    const w = chart.getWidth(), h = chart.getHeight();
    const left = baseGrid.left, right = baseGrid.right, top = baseGrid.top, bottom = baseGrid.bottom;
    const innerW = w - left - right;
    const n = filteredLabels.length;
    const catW = n > 0 ? innerW / n : innerW;

    const gfx = [];
    const palettes = [
      ['#F8FBFF','#EEF6FF','#F2FFF7','#FFF8F2'],
      ['#FFF7EC','#FFF0F3','#F7F7FF','#F3FFF9'],
      ['#F8F9FB','#F3F6FF','#FFF6F3','#F7FFF7'],
      ['#F7FBFF','#FFF7FB','#F7FFF7','#FFF7EF']
    ];

    // For each level except week (so level indices 0..maxDepth-2)
    for (let level = 0; level <= maxDepth-2; level++){
      const groups = filteredGroupsPerLevel[level];
      // vertical position: we stack bands above week axis; compute idxFromBottom as before
      const idxFromBottom = (maxDepth - 1) - level; // for level=maxDepth-2 -> idxFromBottom =1
      const bandTop = h - bottom + (idxFromBottom - 1) * gapBetweenAxes + 6;
      const bandHeight = gapBetweenAxes - 8;
      const palette = palettes[level % palettes.length];
      let colorIdx = 0;
      groups.forEach(g => {
        if (!g.label) { colorIdx = (colorIdx + 1) % palette.length; return; }
        const x = left + g.start * catW;
        const width = (g.end - g.start + 1) * catW;
        gfx.push({
          type: 'rect', z: 1,
          left: x, top: bandTop,
          shape: { width: width, height: bandHeight },
          style: { fill: palette[colorIdx % palette.length], stroke: '#e6e6e6', lineWidth: 1, opacity: 1 },
          silent: true
        });
        gfx.push({
          type: 'text', z: 2,
          left: x + width/2, top: bandTop + bandHeight/2,
          style: { text: g.label, textAlign: 'center', textVerticalAlign: 'middle', fill: '#333', font: (axisLabelFontSize+1)+'px sans-serif' },
          silent: true
        });
        // vertical separator lines
        gfx.push({
          type: 'line', z: 3,
          shape: { x1: x, y1: top - 6, x2: x, y2: h - bottom + maxDepth*gapBetweenAxes + 12 },
          style: { stroke: '#dcdcdc', lineWidth: 1 }
        });
        gfx.push({
          type: 'line', z: 3,
          shape: { x1: x + width, y1: top - 6, x2: x + width, y2: h - bottom + maxDepth*gapBetweenAxes + 12 },
          style: { stroke: '#dcdcdc', lineWidth: 1 }
        });

        colorIdx++;
      });
    }

    // separators for bottom-level groups too (level 0)
    const bottomGroups = groupsFromArray(filteredLayers[0]);
    bottomGroups.forEach(g => {
      const x = left + g.start*catW;
      gfx.push({
        type:'line', z:3,
        shape:{ x1: x, y1: top - 6, x2: x, y2: h - bottom + maxDepth*gapBetweenAxes + 12 },
        style:{ stroke:'#cfcfcf', lineWidth:1 }
      });
    });

    chart.setOption({ graphic: gfx }, { notMerge: false, lazyUpdate: false });

    // update legend in controls to reflect current weeks/ colors (rebuild to show selected)
    updateLegendUI(selectedWeeks);
  }

  // update legend UI (colors)
  function updateLegendUI(selectedWeeks){
    // we will keep checkboxes but ensure color dots visible (already present)
    // Optionally we could show a small legend summary - not needed since checkboxes already include color box
  }

  // initial render
  applyFilterAndRender();

  // resize handler
  window.addEventListener('resize', ()=>{ chart.resize(); setTimeout(()=> applyFilterAndRender(), 120); });

  // ---------------- Streamlit 迁移提示 ----------------
  // 这个 HTML 可以直接嵌入 Streamlit：
  // st.components.v1.html(open("echarts-multilevel-week-color.html").read(), height=800)
  // 如果你要把数据从 Python 端注入 JS，建议在 Streamlit 中用模板替换 rawLabels/rawValues 或用 postMessage 通信更新。

})();
</script>
</body>
</html>
