<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>多级 X 轴（倒序堆叠 + 逐层排序合并）</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: "Microsoft YaHei", Arial, sans-serif; margin: 12px; }
    #main { width: 100%; height: 760px; border: 1px solid #eee; }
    .note { margin-top:10px; color:#666; font-size:13px; }
    .small { font-size:12px; color:#666; }
  </style>
</head>
<body>
  <div id="main"></div>
  <div class="note">说明：先按第一层（集群）排序，再按第二层（型号）、再按第三层（厂商）。层级倒序堆叠（集群最下，厂商最上）。</div>

<script>
(function(){
  // 稳健加载 ECharts
  const ECHARTS_SRC = 'https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js';
  function loadScript(src, cb, eb){ if (window.echarts) return cb(); const s=document.createElement('script'); s.src=src; s.onload=cb; s.onerror=eb; document.head.appendChild(s); }
  loadScript(ECHARTS_SRC, run, function(){ document.getElementById('main').innerText = '无法加载 ECharts，请检查网络或 CDN。'; });

  function run(){
    // ========== 这里放你的 JSON 数据（示例） ==========
    const data = {
      "title": "2025年10月各周不同集群AOC故障数分布",
      "xLabel": "集群.AOC型号.厂商",
      "yLabel": "故障数",
      "labels": [
        "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT",
        "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT",
        "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT",
        "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT",
        "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT",
        "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT",
        "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights",
        "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT",
        "SROCE-TOR下联-QYZNJ01.AOC_QSFPDD.Crealights",
        "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT",
        "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT",
        "ROCE-TOR下联-QYZNJ01.400G_AOC_QSFP112.Crealights",
        "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT",
        "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT"
      ],
      "values": [
        { "data": [1, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "label": "第39周" },
        { "data": [1, 0, 0, 0, 1, 7, 1, 3, 1, 0, 0, 0, 0, 0], "label": "第40周" },
        { "data": [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 1, 0, 0], "label": "第41周" },
        { "data": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], "label": "第42周" }
      ]
    };

    // ========== 配置参数（可按需调整） ==========
    const rawLabels = data.labels.slice();
    const seriesDefs = data.values; // weeks
    const axisLabelFontSize = 13;
    const gapBetweenAxes = 34; // 每层高度
    const extraBottomPadding = 12;
    const gridBase = { left: 130, right: 80, top: 80, bottom: 28 };

    // ---------- 工具函数 ----------
    function splitByDot(labels){
      const rows = labels.map(s => s.split('.'));
      const maxDepth = Math.max(...rows.map(r => r.length));
      rows.forEach(r => { while (r.length < maxDepth) r.push(''); });
      const layers = [];
      for (let l=0; l<maxDepth; l++) layers.push(rows.map(r => r[l]));
      return { rows, layers, maxDepth };
    }
    function groupsFromArray(arr){
      const res=[]; let i=0, n=arr.length;
      while (i<n){
        const v=arr[i]; let j=i+1; while (j<n && arr[j]===v) j++;
        res.push({ start: i, end: j-1, label: v });
        i=j;
      }
      return res;
    }

    // ---------- 逐层排序（hierarchical sort） ----------
    // 比较 keys in order layer0, layer1, ... (stable)
    const parsed = splitByDot(rawLabels);
    const rows = parsed.rows;
    const maxDepth = parsed.maxDepth;

    // build indices and keys
    const indices = rawLabels.map((_, idx) => idx);
    // comparator: compare rows[a][0], rows[a][1], ...
    indices.sort((a, b) => {
      for (let l=0; l<maxDepth; l++){
        const va = (rows[a][l] || '').toString().toLowerCase();
        const vb = (rows[b][l] || '').toString().toLowerCase();
        if (va < vb) return -1;
        if (va > vb) return 1;
      }
      return 0;
    });

    // apply sorted order to labels and series data
    const sortedLabels = indices.map(i => rawLabels[i]);
    const sortedRows = indices.map(i => rows[i].slice());
    // ensure each row padded to maxDepth
    sortedRows.forEach(r => { while (r.length < maxDepth) r.push(''); });
    const sortedSeriesDefs = seriesDefs.map(sd => ({
      label: sd.label,
      data: indices.map(i => sd.data[i] == null ? 0 : sd.data[i])
    }));

    // compute layers/groups on sorted data
    const sortedLayers = [];
    for (let l=0; l<maxDepth; l++) sortedLayers.push(sortedRows.map(r => r[l]));
    const groupsPerLevel = sortedLayers.map(arr => groupsFromArray(arr));

    // week colors & series construction (use sortedSeriesDefs order)
    const weeks = sortedSeriesDefs.map(s => s.label);
    const palette = ['#5470c6','#91cc75','#fac858','#ee6666','#73c0de','#3ba272','#fc8452','#9a60b4','#5ab1ef'];
    const weekColor = {}; weeks.forEach((w,i)=> weekColor[w] = palette[i % palette.length]);

    const series = sortedSeriesDefs.map(sd => ({
      name: sd.label,
      type: 'bar',
      data: sd.data,
      itemStyle: { color: weekColor[sd.label] },
      barGap: '10%'
    }));

    // ---------- 动态 grid.bottom，留出 reserved area for bands ----------
    const reservedAreaHeight = maxDepth * gapBetweenAxes + extraBottomPadding;
    const grid = Object.assign({}, gridBase, { bottom: gridBase.bottom + reservedAreaHeight });

    // ---------- initialize chart (one invisible category axis for positions) ----------
    const chart = echarts.init(document.getElementById('main'));
    const option = {
      title: { text: data.title, left: 'center' },
      tooltip: {
        trigger: 'axis',
        axisPointer: { type: 'shadow' },
        formatter: function(params){
          if (!params || !params.length) return '';
          const idx = params[0].dataIndex;
          const fullLabel = sortedLabels[idx];
          let html = `<div style="white-space:nowrap;"><b>${fullLabel}</b><br/>`;
          params.forEach(p => {
            html += `<span style="display:inline-block;width:10px;height:10px;background:${p.color};margin-right:6px;border-radius:2px;vertical-align:middle;"></span>${p.seriesName}: ${p.data}<br/>`;
          });
          html += '</div>';
          return html;
        }
      },
      legend: { top: 36, right: grid.right - 10, orient: 'vertical' },
      grid: { left: grid.left, right: grid.right, top: grid.top, bottom: grid.bottom },
      xAxis: [{
        type: 'category',
        data: sortedLabels.map((_,i) => i.toString()),
        axisLine: { show: false },
        axisTick: { show: false },
        axisLabel: { show: false }
      }],
      yAxis: [{ type: 'value', name: data.yLabel }],
      series: series,
      graphic: []
    };
    chart.setOption(option);

    // ---------- render bands (倒序堆叠：集群(level0)在最下，厂商(levelN)在最上) ----------
    function wrapText(text, maxLen){
      if (!text) return '';
      if (text.length <= maxLen) return text;
      const parts = [];
      for (let i=0;i<text.length;i+=maxLen) parts.push(text.slice(i, i+maxLen));
      return parts.join('\n');
    }

    function renderBands(){
      const w = chart.getWidth(), h = chart.getHeight();
      const left = grid.left, right = grid.right, top = grid.top, bottom = grid.bottom;
      const innerW = w - left - right;
      const n = sortedLabels.length;
      const catW = n > 0 ? innerW / n : innerW;

      const gfx = [];
      const palettes = [
        ['#F8FBFF','#EEF6FF','#F2FFF7','#FFF8F2'],
        ['#FFF7EC','#FFF0F3','#F7F7FF','#F3FFF9'],
        ['#F8F9FB','#F3F6FF','#FFF6F3','#F7FFF7'],
        ['#F7FBFF','#FFF7FB','#F7FFF7','#FFF7EF']
      ];

      // reservedTop is the top of reserved area: it is at canvas height - grid.bottom
      const reservedTop = h - bottom;
      // We want level0 (cluster) to be closest to bars (i.e. lowest band), and level (maxDepth-1) (vendor) highest.
      // So for level L, compute offset = (maxDepth - 1 - L)
      for (let level = 0; level < maxDepth; level++){
        const groups = groupsPerLevel[level];
        const palette = palettes[level % palettes.length];
        let colorIdx = 0;
        // levelOffset: 0 for topmost band? we want topmost (vendor) to have smallest bandTop,
        // so bandTop = reservedTop + ( (maxDepth - 1 - level) * gapBetweenAxes ) + padding
        const bandTop = Math.round(reservedTop + ( (maxDepth - 1 - level) * gapBetweenAxes ) + 6);
        const bandHeight = gapBetweenAxes - 8;

        groups.forEach(g => {
          const label = g.label || '';
          const x = left + g.start * catW;
          const width = (g.end - g.start + 1) * catW;

          // draw rect for group
          gfx.push({
            type: 'rect', z: 1,
            left: x, top: bandTop,
            shape: { width: width, height: bandHeight },
            style: { fill: palette[colorIdx % palette.length], stroke: '#e6e6e6', lineWidth: 1, opacity: 1 },
            silent: true
          });

          if (label) {
            // center text; shorten if too long
            const display = wrapText(label, 18);
            gfx.push({
              type: 'text', z: 2,
              left: x + width/2, top: bandTop + bandHeight/2,
              style: { text: display, textAlign: 'center', textVerticalAlign: 'middle', fill: '#222', font: (axisLabelFontSize) + 'px sans-serif' },
              silent: true
            });
          }

          // vertical separators covering plotting area + reserved area
          gfx.push({
            type: 'line', z: 3,
            shape: { x1: x, y1: top - 6, x2: x, y2: h - 6 },
            style: { stroke: '#ddd', lineWidth: 1 }
          });
          gfx.push({
            type: 'line', z: 3,
            shape: { x1: x + width, y1: top - 6, x2: x + width, y2: h - 6 },
            style: { stroke: '#ddd', lineWidth: 1 }
          });

          colorIdx++;
        });
      }

      chart.setOption({ graphic: gfx }, { notMerge: false, lazyUpdate: false });
    }

    // initial paint
    renderBands();

    // resize handling
    window.addEventListener('resize', function(){ chart.resize(); setTimeout(renderBands, 120); });

    // 暴露以供调试
    window.__multi = { chart, sortedLabels, sortedRows, groupsPerLevel, renderBands };
  } // end run
})();
</script>
</body>
</html>
