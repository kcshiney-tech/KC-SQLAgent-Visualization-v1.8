<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>ECharts 多级 X 轴 — 跨列背景带、分隔线、按周着色、完整 tooltip</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <style>
    body { font-family: "Microsoft YaHei", Arial, sans-serif; margin: 12px; }
    #main { width: 100%; height: 740px; border: 1px solid #eee; }
    h3 { margin-bottom:6px; }
    .note { color:#666; font-size:13px; margin-top:8px; }
  </style>
</head>
<body>
  <h3>ECharts 多级 X 轴（增强版：带跨列背景带 / 分隔线 / 按周着色 / 完整 tooltip）</h3>
  <div id="main"></div>
  <div class="note">
    说明：按 <code>.</code> 分层（不会把 ROCE 单独拆开）。第一层（例如 QYYDxx）放在最底部。组使用不同浅色背景带，并在组边界画竖线分隔；柱子颜色按周区分；悬停显示完整原始标签 + 数字。
  </div>

<script>
(function(){
  // ---------------- 原始数据 ----------------
  const rawLabels = [
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-30",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-40",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-41",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-42",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-39",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-40",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-41",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-42",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-39",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-40",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-41",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-42",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-39",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-40",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-41",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-42",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-39",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-40",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-41",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-42",
    "ROCE-TOR下联-QYZNJ01.400G_AOC_QSFP112.Crealights.2025-41",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-39",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-40",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-42",
    "ROCE-TOR下联-QYZNJ01.AOC_QSFPDD.Crealights.2025-40"
  ];

  const values = [0,0,2,0,1,1,0,0,0,3,0,0,7,0,0,0,4,1,1,1,1,2,3,1,1];

  // ---------------- 拆层：只按 '.' 分割 ----------------
  function splitByDot(s){ return s.split('.'); }
  const layerRows = rawLabels.map(splitByDot);
  const maxDepth = Math.max(...layerRows.map(r=>r.length));

  // pad shorter rows to maxDepth
  for (let i=0;i<layerRows.length;i++){
    while (layerRows[i].length < maxDepth) layerRows[i].push('');
  }

  // layers[level] is array of labels at that level for all entries
  const layers = [];
  for (let l=0;l<maxDepth;l++){
    layers.push(layerRows.map(r => r[l]));
  }

  // ---------------- 计算组（连续相同值） ----------------
  function groupsFromArray(arr){
    const groups = [];
    let i=0, n=arr.length;
    while (i<n){
      const v = arr[i];
      let j = i+1;
      while (j<n && arr[j] === v) j++;
      groups.push({ start: i, end: j-1, label: v });
      i = j;
    }
    return groups;
  }
  const groupsPerLevel = layers.map(level => groupsFromArray(level));

  // ---------------- 周（week）用于柱子上色 ----------------
  const weeks = layerRows.map(r => r[r.length - 1] || '');
  const uniqueWeeks = Array.from(new Set(weeks));
  // palette for weeks
  const weekPalette = ['#5470c6','#91cc75','#fac858','#ee6666','#73c0de','#3ba272','#fc8452','#9a60b4','#ea7ccc'];
  const weekColorMap = {};
  uniqueWeeks.forEach((w,i)=> weekColorMap[w] = weekPalette[i % weekPalette.length]);

  // series data with itemStyle color by week
  const seriesData = values.map((v, idx) => ({
    value: v,
    itemStyle: { color: weekColorMap[weeks[idx]] || '#5470c6' }
  }));

  // ---------------- 画布布局和 xAxis 构建（倒序堆叠：level0最底部） ----------------
  const axisLabelFontSize = 13;
  const gapBetweenAxes = 30;
  const extraBottom = 20; // padding
  const baseGrid = {
    left: 90,
    right: 40,
    top: 80,
    bottom: 20 + (maxDepth) * gapBetweenAxes + extraBottom
  };

  // create xAxes from level0 (bottom) up to level maxDepth-1 (top)
  const xAxes = [];
  for (let level = 0; level < maxDepth; level++){
    const isBottom = (level === 0); // level 0 is bottom per user requirement
    // label array: for bottom (level0) show the level's labels (e.g., QYYDxx or cluster-model),
    // for others show blank because we'll render group labels via graphic bands (we also show week on a dedicated axis if needed)
    let labelArr;
    if (isBottom) {
      labelArr = layers[level].map(s => s || '');
    } else if (level === maxDepth - 1) {
      // topmost: we will display week text (to ensure week visible on axis)
      labelArr = weeks.map(w => w);
    } else {
      // hide labels on intermediate axes (we will draw text on bands)
      labelArr = new Array(rawLabels.length).fill('');
    }

    const offset = level * gapBetweenAxes; // stack upward from bottom
    xAxes.push({
      type: 'category',
      position: 'bottom',
      offset: offset,
      data: labelArr,
      axisLine: { show: false },
      axisTick: { show: isBottom, alignWithLabel: true, length: isBottom ? 6 : 0 },
      axisLabel: {
        interval: 0,
        rotate: 0,
        show: true,
        color: '#222',
        fontSize: axisLabelFontSize,
        formatter: function(v) { return v; },
        align: 'center'
      },
      splitLine: { show: false },
      axisPointer: { show: false }
    });
  }

  // ---------------- base option ----------------
  const option = {
    title: { text: '2025年10月各集群AOC故障数按型号/厂商/周分组', left: 'center' },
    grid: baseGrid,
    tooltip: {
      trigger: 'item',
      axisPointer: { type: 'shadow' },
      formatter: function(params){
        if (!params) return '';
        const idx = params.dataIndex;
        const value = params.value && params.value.value !== undefined ? params.value.value : params.value;
        return `<div style="white-space:nowrap;">${rawLabels[idx]}<br/>故障数: <b>${value}</b></div>`;
      }
    },
    xAxis: xAxes,
    yAxis: { type: 'value', name: '故障数', nameLocation: 'end', nameGap: 18 },
    series: [{
      name: '故障数',
      type: 'bar',
      data: seriesData,
      barMaxWidth: 26,
      xAxisIndex: 0, // bottom-most axis used for plotting positions
      itemStyle: { opacity: 1 }
    }],
    graphic: [] // will populate with background bands and vertical separators
  };

  const chart = echarts.init(document.getElementById('main'));
  chart.setOption(option);

  // ---------------- draw bands and vertical separators using graphic ----------------
  function renderGraphics(){
    const w = chart.getWidth();
    const h = chart.getHeight();
    const left = baseGrid.left;
    const right = baseGrid.right;
    const top = baseGrid.top;
    const bottom = baseGrid.bottom;
    const innerW = w - left - right;
    const n = rawLabels.length;
    const catW = innerW / n;

    const gfx = [];
    // palette for bands per level, but within same level use different colors per group
    const levelPalettes = [
      ['#f8fbff','#eef6ff','#f2fff7','#fff8f2'],
      ['#fff7ec','#fff0f3','#f7f7ff','#f3fff9'],
      ['#f8f9fb','#f3f6ff','#fff6f3','#f7fff7'],
      ['#f7fbff','#fff7fb','#f7fff7','#fff7ef']
    ];
    // For each level, draw group's background rect and centered label (except bottom-most which already shows labels)
    for (let level = 0; level < maxDepth; level++){
      if (level === 0) continue; // skip bottom-most level for bands (bottom axis labels already visible)
      const groups = groupsPerLevel[level];
      // vertical position for band: place just above the axis line for that level
      const bandTop = h - bottom + (level) * gapBetweenAxes + 6; // 6 px padding
      const bandHeight = gapBetweenAxes - 8;
      const palette = levelPalettes[level % levelPalettes.length];
      let colorIdx = 0;

      groups.forEach(g => {
        if (!g.label) {
          colorIdx = (colorIdx + 1) % palette.length;
          return;
        }
        const x = left + g.start * catW;
        const width = (g.end - g.start + 1) * catW;
        // rect
        gfx.push({
          type: 'rect',
          z: 1,
          left: x,
          top: bandTop,
          shape: { width: width, height: bandHeight },
          style: { fill: palette[colorIdx % palette.length], stroke: '#e0e0e0', lineWidth: 1, opacity: 1 },
          silent: true
        });
        // centered text label
        gfx.push({
          type: 'text',
          z: 2,
          left: x + width/2,
          top: bandTop + bandHeight/2,
          style: {
            text: g.label,
            textAlign: 'center',
            textVerticalAlign: 'middle',
            fill: '#333',
            font: (axisLabelFontSize+1) + 'px sans-serif'
          },
          silent: true
        });
        // vertical separators at group boundaries (left and right)
        gfx.push({
          type: 'line',
          z: 3,
          shape: {
            x1: x, y1: top - 6, // extend above the chart plot area a bit
            x2: x, y2: h - bottom + maxDepth*gapBetweenAxes + 12 // extend downward to cover axis area
          },
          style: { stroke: '#e0e0e0', lineWidth: 1, opacity: 0.9 },
          silent: true
        });
        // also draw the right vertical border
        gfx.push({
          type: 'line',
          z: 3,
          shape: {
            x1: x + width, y1: top - 6,
            x2: x + width, y2: h - bottom + maxDepth*gapBetweenAxes + 12
          },
          style: { stroke: '#e0e0e0', lineWidth: 1, opacity: 0.9 },
          silent: true
        });

        colorIdx++;
      });
    }

    // small vertical separators for bottom-level groups too (if you want clear partition)
    // draw separators at boundaries of groups in level 0 (bottom)
    const bottomGroups = groupsPerLevel[0];
    bottomGroups.forEach(g => {
      const x = left + (g.start) * catW;
      // left border
      gfx.push({
        type: 'line', z: 3,
        shape: { x1: x, y1: baseGrid.top - 6, x2: x, y2: h - bottom + maxDepth*gapBetweenAxes + 12 },
        style: { stroke: '#dcdcdc', lineWidth: 1 }
      });
    });

    chart.setOption({ graphic: gfx });
  }

  // initial render
  renderGraphics();

  // responsive: resize and re-render graphics after a short delay
  window.addEventListener('resize', function(){ chart.resize(); setTimeout(renderGraphics, 120); });

  // ---------------- 可选：点击 group 高亮（示例） ----------------
  // 当点击 band 区域时，高亮对应 index 范围的柱子（示例，非必需）
  chart.getZr().on('click', function(event){
    // find which band text or rect clicked by checking coordinates against graphics
    // (left as future enhancement—graphic 点击需要 mapping，这里暂不实现自动点击）
  });

  // debug logs
  console.log('maxDepth:', maxDepth);
  console.log('layers:', layers);
  console.log('groupsPerLevel:', groupsPerLevel);
  console.log('uniqueWeeks:', uniqueWeeks);
})();
</script>
</body>
</html>
