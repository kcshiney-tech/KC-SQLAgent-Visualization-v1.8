<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>多级 X 轴 — 去重并合并周数据（示例）</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: "Microsoft YaHei", Arial, sans-serif; margin: 12px; }
    #main { width: 100%; height: 780px; border: 1px solid #eee; }
    .note { margin-top:10px; color:#666; font-size:13px; }
  </style>
</head>
<body>
  <div id="main"></div>
  <div class="note">说明：先去重横坐标（相同完整标签合并），每周数据按标签求和合并，再做多级分组与渲染。</div>

<script>
(function(){
  // 稳健加载 ECharts
  const ECHARTS_SRC = 'https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js';
  function loadScript(src, cb, eb){ if (window.echarts) return cb(); const s = document.createElement('script'); s.src = src; s.onload = cb; s.onerror = eb; document.head.appendChild(s); }
  loadScript(ECHARTS_SRC, init, function(){ document.getElementById('main').innerText = '无法加载 ECharts，请检查网络或 CDN。'; });

  function init(){
    // ========== 原始数据（与示例一致） ==========
    const data = {
      "title": "2025年10月各周不同集群AOC故障数分布",
      "xLabel": "集群.AOC型号.厂商",
      "yLabel": "故障数",
      "labels": [
        "QHDX03.400G_AOC_QSFP112.SONT",
        "QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT",
        "QYYD06.400G_AOC_QSFP112.SONT",
        "QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT",
        "QHDX03.400G_AOC_QSFP112.SONT",
        "QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT",
        "QYYD05.AOC_QSFPDD.Crealights",
        "QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT",
        "QYZNJ01.AOC_QSFPDD.Crealights",
        "QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT",
        "QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT",
        "QYZNJ01.400G_AOC_QSFP112.Crealights",
        "QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT",
        "QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT"
      ],
      "values": [
        { "data": [1, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "label": "第39周" },
        { "data": [1, 0, 0, 0, 1, 7, 1, 3, 1, 0, 0, 0, 0, 0], "label": "第40周" },
        { "data": [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 1, 0, 0], "label": "第41周" },
        { "data": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], "label": "第42周" }
      ]
    };

    // ====== 配置 ======
    const fontSize = 11;   // 标签字号（不换行）
    const gapBetweenAxes = 30;
    const extraBottomPadding = 10;
    const gridBase = { left: 120, right: 60, top: 80, bottom: 28 };

    // ====== 1) 去重并合并周数据（按标签字符串完全匹配） ======
    const origLabels = data.labels;
    const weeks = data.values.map(s => s.label);
    // map: label -> mergedIndex
    const labelMap = new Map();
    const uniqueLabels = [];
    // initialize mergedData per week as arrays
    const mergedWeekData = weeks.map(() => []); // will push zeros later

    // Build mapping by iterating original labels in order; for each label, find or create unique index,
    // and accumulate each week's value to mergedWeekData[weekIdx][uniqueIndex]
    for (let i = 0; i < origLabels.length; i++){
      const lbl = origLabels[i];
      let idx;
      if (labelMap.has(lbl)) {
        idx = labelMap.get(lbl);
      } else {
        idx = uniqueLabels.length;
        uniqueLabels.push(lbl);
        labelMap.set(lbl, idx);
        // initialize zeros for each week at this new idx
        for (let w = 0; w < mergedWeekData.length; w++) mergedWeekData[w][idx] = 0;
      }
      // for each week, add value at original position i
      for (let w = 0; w < weeks.length; w++){
        const val = (data.values[w].data[i] == null) ? 0 : Number(data.values[w].data[i]);
        mergedWeekData[w][idx] = (mergedWeekData[w][idx] || 0) + val;
      }
    }

    // Now uniqueLabels and mergedWeekData arrays are aligned:
    // mergedWeekData[w] is array of length uniqueLabels.length with summed values.

    // ====== 2) 构建 per-week series using merged data ======
    const palette = ['#5470c6','#91cc75','#fac858','#ee6666','#73c0de','#3ba272','#fc8452','#9a60b4','#5ab1ef'];
    const series = weeks.map((wk, widx) => ({
      name: wk,
      type: 'bar',
      data: mergedWeekData[widx].map(v => v == null ? 0 : v),
      itemStyle: { color: palette[widx % palette.length] },
      barMaxWidth: 30
    }));

    // ====== 3) 对唯一标签进行层级拆分与逐层分组（父受限） ======
    // split unique labels by '.' into layers
    function splitRows(labels){
      const rows = labels.map(s => s.split('.'));
      const maxDepth = Math.max(...rows.map(r => r.length));
      rows.forEach(r => { while (r.length < maxDepth) r.push(''); });
      return { rows, maxDepth };
    }
    const parsed = splitRows(uniqueLabels);
    const rows = parsed.rows;
    const maxDepth = parsed.maxDepth;

    // hierarchical grouping: recursively group children only inside parent range
    function makeNode(start, end, label){ return { start, end, label, children: [] }; }
    function buildHierarchy(rows){
      function build(level, s, e){
        const nodes = [];
        if (level >= rows[0].length) return nodes;
        let i = s;
        while (i <= e){
          const val = rows[i][level];
          let j = i + 1;
          while (j <= e && rows[j][level] === val) j++;
          const node = makeNode(i, j-1, val === '' ? '' : val);
          node.children = build(level + 1, i, j-1);
          nodes.push(node);
          i = j;
        }
        return nodes;
      }
      return build(0, 0, rows.length - 1);
    }
    const rootGroups = buildHierarchy(rows);
    function collectGroupsByLevel(rootNodes, depth){
      const out = Array.from({length: depth}, () => []);
      function dfs(nodes, level){
        for (const n of nodes){
          out[level].push({ start: n.start, end: n.end, label: n.label });
          if (n.children && n.children.length) dfs(n.children, level+1);
        }
      }
      dfs(rootNodes, 0);
      return out;
    }
    const groupsPerLevel = collectGroupsByLevel(rootGroups, maxDepth);

    // ====== 4) 构建 ECharts option 并渲染 graphic（多级合并带 + 分隔线） ======
    const chart = echarts.init(document.getElementById('main'));
    const reservedAreaHeight = maxDepth * gapBetweenAxes + extraBottomPadding;
    const grid = Object.assign({}, gridBase, { bottom: gridBase.bottom + reservedAreaHeight });

    const option = {
      title: { text: data.title, left: 'center' },
      tooltip: {
        trigger: 'axis',
        axisPointer: { type: 'shadow' },
        formatter: function(params){
          if (!params || !params.length) return '';
          const idx = params[0].dataIndex;
          const label = uniqueLabels[idx];
          let html = `<div style="white-space:nowrap;"><b>${label}</b><br/>`;
          params.forEach(p => {
            html += `<span style="display:inline-block;width:10px;height:10px;background:${p.color};margin-right:6px;border-radius:2px;vertical-align:middle;"></span> ${p.seriesName}: ${p.data}<br/>`;
          });
          html += '</div>';
          return html;
        }
      },
      legend: { top: 36, right: grid.right - 10 },
      grid: { left: grid.left, right: grid.right, top: grid.top, bottom: grid.bottom },
      xAxis: [{
        type: 'category',
        data: uniqueLabels.map((_,i) => i.toString()),
        axisLine: { show:false }, axisTick: { show:false }, axisLabel: { show:false }
      }],
      yAxis: [{ type: 'value', name: data.yLabel }],
      series: series,
      graphic: []
    };

    chart.setOption(option);

    // draw bands and centered labels (no wrap, smaller font)
    function renderBands(){
      const w = chart.getWidth(), h = chart.getHeight();
      const left = grid.left, right = grid.right, top = grid.top, bottom = grid.bottom;
      const innerW = w - left - right;
      const n = uniqueLabels.length;
      const catW = n > 0 ? innerW / n : innerW;

      const gfx = [];
      const palettes = [
        ['#F8FBFF','#EEF6FF','#F2FFF7','#FFF8F2'],
        ['#FFF7EC','#FFF0F3','#F7F7FF','#F3FFF9'],
        ['#F8F9FB','#F3F6FF','#FFF6F3','#F7FFF7'],
        ['#F7FBFF','#FFF7FB','#F7FFF7','#FFF7EF']
      ];

      const reservedTop = h - bottom;
      // vertical stacking inverted: level 0 (cluster) closest to bars, level maxDepth-1 topmost
      for (let level = 0; level < maxDepth; level++){
        const groups = groupsPerLevel[level];
        const palette = palettes[level % palettes.length];
        let colorIdx = 0;
        const bandTop = Math.round(reservedTop + ((maxDepth - 1 - level) * gapBetweenAxes) + 6);
        const bandHeight = gapBetweenAxes - 8;

        for (const g of groups){
          const lbl = g.label || '';
          const x = left + g.start * catW;
          const width = (g.end - g.start + 1) * catW;

          gfx.push({
            type: 'rect', z: 1,
            left: x, top: bandTop,
            shape: { width: width, height: bandHeight },
            style: { fill: palette[colorIdx % palette.length], stroke: '#e6e6e6', lineWidth: 1, opacity: 1 },
            silent: true
          });

          if (lbl) {
            // NO wrap: single-line smaller font
            gfx.push({
              type: 'text', z: 2,
              left: x + width/2, top: bandTop + bandHeight/2,
              style: { text: lbl, textAlign: 'center', textVerticalAlign: 'middle', fill: '#222', font: fontSize + 'px sans-serif' },
              silent: true
            });
          }

          // separators
          gfx.push({
            type: 'line', z: 3,
            shape: { x1: x, y1: top - 6, x2: x, y2: h - 6 },
            style: { stroke: '#ddd', lineWidth: 1 }
          });
          gfx.push({
            type: 'line', z: 3,
            shape: { x1: x + width, y1: top - 6, x2: x + width, y2: h - 6 },
            style: { stroke: '#ddd', lineWidth: 1 }
          });

          colorIdx++;
        }
      }

      chart.setOption({ graphic: gfx }, { notMerge: false, lazyUpdate: false });
    }

    renderBands();
    window.addEventListener('resize', function(){ chart.resize(); setTimeout(renderBands, 120); });

    // Expose for debugging
    window._multi = { uniqueLabels, mergedWeekData, groupsPerLevel, chart };
  } // end init
})();
</script>
</body>
</html>
