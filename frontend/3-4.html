<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>ECharts 多级 X 轴 — 跨列背景带 + tooltip</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <style>
    body { font-family: "Microsoft YaHei", Arial, sans-serif; margin: 12px; }
    #main { width: 100%; height: 700px; border: 1px solid #eee; }
    h3 { margin-bottom: 6px; }
  </style>
</head>
<body>
  <h3>ECharts 多级 X 轴（带跨列背景带）</h3>
  <div id="main"></div>

<script>
(function(){
  const rawLabels = [
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-30",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-40",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-41",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-42",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-39",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-40",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-41",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-42",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-39",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-40",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-41",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-42",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-39",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-40",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-41",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-42",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-39",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-40",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-41",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-42",
    "ROCE-TOR下联-QYZNJ01.400G_AOC_QSFP112.Crealights.2025-41",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-39",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-40",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-42",
    "ROCE-TOR下联-QYZNJ01.AOC_QSFPDD.Crealights.2025-40"
  ];

  const values = [0,0,2,0,1,1,0,0,0,3,0,0,7,0,0,0,4,1,1,1,1,2,3,1,1];

  // ---------- split into layers using '.' ONLY (so ROCE不会被拆) ----------
  function splitByDot(s){
    return s.split('.');
  }
  const layerRows = rawLabels.map(splitByDot);
  const maxDepth = Math.max(...layerRows.map(r => r.length));

  // pad to same length
  for (let i=0;i<layerRows.length;i++){
    while (layerRows[i].length < maxDepth) layerRows[i].push('');
  }

  // layers[level] is array of labels at that level for all categories
  const layers = [];
  for (let l=0;l<maxDepth;l++){
    layers.push(layerRows.map(r => r[l]));
  }

  // ---------- compute groups per level (contiguous equal values) ----------
  function groupsFromArray(arr){
    const groups = [];
    let i=0;
    const n = arr.length;
    while (i<n){
      const v = arr[i];
      let j = i+1;
      while (j<n && arr[j] === v) j++;
      // group [i, j-1], label = v
      groups.push({start: i, end: j-1, label: v});
      i = j;
    }
    return groups;
  }

  const groupsPerLevel = layers.map(levelArr => groupsFromArray(levelArr));

  // ---------- Build base option with multiple xAxis (one per level) ----------
  const axisLabelFontSize = 12; // slightly larger
  const gapBetweenAxes = 26;    // pixel gap between axis label rows
  const baseGrid = { left: 80, right: 30, top: 80, bottom: 30 + maxDepth * gapBetweenAxes };

  // For each level produce an xAxis. Bottom-most (level = maxDepth-1) shows ticks and short labels (week),
  // higher levels show only the mid-point label text (we will draw background bands separately).
  const xAxes = [];
  for (let level = 0; level < maxDepth; level++){
    const isBottom = (level === maxDepth - 1);
    const labelArr = isBottom ? rawLabels.map(s => {
      const parts = s.split('.');
      return parts[parts.length - 1]; // bottom display: week string like '2025-30'
    }) : new Array(rawLabels.length).fill(''); // leave empty: we render group text via graphic to avoid overlap

    // axis offset (stack upwards)
    const idxFromBottom = (maxDepth - 1) - level; // 0 bottom
    const offset = idxFromBottom * gapBetweenAxes;

    xAxes.push({
      type: 'category',
      position: 'bottom',
      offset: offset,
      data: labelArr,
      axisLine: { show: false },
      axisTick: { show: isBottom, alignWithLabel: true, length: isBottom ? 6 : 0 },
      axisLabel: {
        interval: 0,
        rotate: 0,
        show: true,
        color: '#222',
        fontSize: axisLabelFontSize,
        formatter: function(v) { return v; },
        align: 'center'
      },
      splitLine: { show: false },
      axisPointer: { show: false }
    });
  }

  // ---------- base option ----------
  const option = {
    title: { text: '2025年10月各集群AOC故障数按型号、厂商、周分布', left: 'center' },
    grid: baseGrid,
    tooltip: {
      trigger: 'axis',
      axisPointer: { type: 'shadow' },
      formatter: function(params){
        if (!params || !params.length) return '';
        const p = params[0];
        const idx = p.dataIndex;
        return rawLabels[idx] + '<br/>' + p.seriesName + ': ' + p.data;
      }
    },
    xAxis: xAxes,
    yAxis: { type: 'value', name: '故障数', nameLocation: 'end', nameGap: 20 },
    series: [
      {
        name: '故障数',
        type: 'bar',
        data: values,
        barMaxWidth: 26,
        itemStyle: { color: '#5470c6' },
        // map to bottom-most axis
        xAxisIndex: maxDepth - 1
      }
    ],
    graphic: [] // will fill with background bands and group labels
  };

  const chart = echarts.init(document.getElementById('main'));
  chart.setOption(option);

  // ---------- After chart rendered, compute pixel positions and draw background rectangles via graphic ----------
  function renderBands(){
    const chartWidth = chart.getWidth();
    const chartHeight = chart.getHeight();
    // grid in px
    const grid = baseGrid;
    const left = grid.left;
    const right = grid.right;
    const top = grid.top;
    const bottom = grid.bottom;
    const innerWidth = chartWidth - left - right;
    const n = rawLabels.length;
    const bandElements = [];
    // category width in px
    const catW = innerWidth / n;

    // For each level (except bottom), draw bands for groups
    for (let level = 0; level < maxDepth - 1; level++){
      const groups = groupsPerLevel[level];
      // compute vertical band position: bands will be placed under the axes labels area,
      // y coordinate measured from top of container: we place near bottom - (levelOffset)
      // baseline for axis labels area top:
      const axisAreaTop = chartHeight - bottom; // top of bottom grid area
      // place bands below the grid and above bottom-most axis labels; we offset by small amount
      const bandTop = axisAreaTop + 6 + level * (gapBetweenAxes); // adjust 6px padding
      const bandHeight = gapBetweenAxes - 6; // height per band
      // choose color palette (semi-transparent)
      const palette = ['#F3F6FF', '#F9F7EF', '#F3FFF6', '#FFF3F6', '#F7F3FF'];
      const color = palette[level % palette.length];

      groups.forEach(g => {
        if (!g.label) return; // skip empty grouping label
        const x = left + g.start * catW;
        const w = (g.end - g.start + 1) * catW;
        // create rectangle graphic element
        bandElements.push({
          type: 'rect',
          z: 1,
          left: x,
          top: bandTop,
          shape: { width: w, height: bandHeight },
          style: { fill: color, stroke: '#e6e6e6', lineWidth: 1, opacity: 1 },
          silent: true
        });
        // add text centered in that rect
        bandElements.push({
          type: 'text',
          z: 2,
          left: x + w / 2,
          top: bandTop + bandHeight / 2,
          style: {
            text: g.label,
            textAlign: 'center',
            textVerticalAlign: 'middle',
            fill: '#333',
            font: (axisLabelFontSize + 1) + 'px sans-serif'
          },
          silent: true
        });
      });
    }

    // set graphic
    chart.setOption({ graphic: bandElements });
  }

  // initial render bands
  renderBands();

  // handle resize and re-render bands
  window.addEventListener('resize', function(){
    chart.resize();
    // small timeout to allow chart to adjust
    setTimeout(renderBands, 120);
  });

  // debug logs
  console.log('layers:', layers);
  console.log('groupsPerLevel:', groupsPerLevel);

})();
</script>
</body>
</html>
