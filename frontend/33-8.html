<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>ECharts 多级 X 轴（稳健加载版）</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: "Microsoft YaHei", Arial, sans-serif; margin: 12px; }
    #container { position: relative; width: 100%; max-width: 1280px; margin: 0 auto; }
    #main { width: 100%; height: 720px; border: 1px solid #eee; }
    .controls {
      position: absolute; right: 12px; top: 12px;
      background: rgba(255,255,255,0.98);
      border: 1px solid #ddd; padding: 8px 10px; border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.06); font-size: 13px; z-index: 1000;
      max-height: 380px; overflow: auto; min-width: 220px;
    }
    .controls h4 { margin: 0 0 6px 0; font-size: 13px; }
    .controls label { display: flex; align-items: center; gap:8px; margin: 6px 0; cursor: pointer; }
    .legend-color { width: 14px; height: 12px; border-radius: 2px; display:inline-block; vertical-align:middle; margin-right:6px; border:1px solid #ccc; }
    .actions { margin-top:6px; display:flex; gap:8px; }
    .note { margin-top:8px; color:#666; font-size:13px; }
    .error { color: #b05; margin-top: 12px; font-weight: 600; }
    .retry { margin-top:8px; }
  </style>
</head>
<body>
  <div id="container">
    <div id="main"></div>

    <div class="controls" id="controls">
      <h4>周筛选（颜色即区分）</h4>
      <div id="week-checkboxes"></div>
      <div class="actions">
        <button id="select-all">全选</button>
        <button id="clear-all">取消</button>
      </div>
      <div style="margin-top:8px;font-size:12px;color:#666">提示：轴上不显示周文本，柱子颜色代表不同周。</div>
    </div>
  </div>

  <div class="note">
    说明：按 <code>.</code> 分层（不会拆分 ROCE），最靠近柱子的层为周（颜色区分），最远为顶层。页面会动态加载 ECharts（若加载失败会提示）。
  </div>

  <div id="load-error" style="display:none;">
    <div class="error">无法加载 ECharts 脚本（网络或 CDN 问题）。</div>
    <div class="retry"><button id="retry-load">重试加载 ECharts</button></div>
  </div>

<script>
(function(){
  // 动态加载脚本并在加载完成后执行 initChart()
  const ECHARTS_CDN = 'https://cdn.jsdelivr.net/npm/echarts@5.5.2/dist/echarts.min.js';

  function loadScript(src, cb, errCb) {
    const existing = document.querySelector('script[data-src="'+src+'"]');
    if (existing) {
      // script already injected — check if loaded
      if (window.echarts) return cb();
      // otherwise attach onload/onerror
      existing.addEventListener('load', cb);
      existing.addEventListener('error', errCb);
      return;
    }
    const s = document.createElement('script');
    s.src = src;
    s.async = true;
    s.setAttribute('data-src', src);
    s.onload = cb;
    s.onerror = errCb;
    document.head.appendChild(s);
  }

  function showLoadError() {
    document.getElementById('load-error').style.display = 'block';
  }
  function hideLoadError() {
    document.getElementById('load-error').style.display = 'none';
  }

  function initAfterEcharts() {
    // 确保 echarts 存在
    if (!window.echarts) {
      showLoadError();
      return;
    }
    hideLoadError();
    try {
      initChart(window.echarts);
    } catch (e) {
      console.error('初始化图表时出错:', e);
      showLoadError();
    }
  }

  // 绑定重试按钮
  document.getElementById('retry-load').addEventListener('click', function(){
    hideLoadError();
    loadScript(ECHARTS_CDN, initAfterEcharts, showLoadError);
  });

  // 首次加载
  loadScript(ECHARTS_CDN, initAfterEcharts, showLoadError);

  // ----------------- chart logic (same as修复版) -----------------
  function initChart(echarts){
    // data — 可替换
    const rawLabels = [
      "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-30",
      "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-40",
      "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-41",
      "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-42",
      "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-39",
      "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-40",
      "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-41",
      "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-42",
      "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-39",
      "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-40",
      "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-41",
      "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-42",
      "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-39",
      "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-40",
      "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-41",
      "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-42",
      "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-39",
      "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-40",
      "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-41",
      "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-42",
      "ROCE-TOR下联-QYZNJ01.400G_AOC_QSFP112.Crealights.2025-41",
      "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-39",
      "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-40",
      "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-42",
      "ROCE-TOR下联-QYZNJ01.AOC_QSFPDD.Crealights.2025-40"
    ];
    const rawValues = [0,0,2,0,1,1,0,0,0,3,0,0,7,0,0,0,4,1,1,1,1,2,3,1,1];

    const axisLabelFontSize = 13;
    const gapBetweenAxes = 32;
    const baseGrid = { left: 120, right: 40, top: 80, bottom: 24 };

    // helper funcs (same as before)
    function splitIntoLayers(labels){
      const rows = labels.map(s => s.split('.'));
      const maxDepth = Math.max(...rows.map(r => r.length));
      rows.forEach(r => { while (r.length < maxDepth) r.push(''); });
      const layers = [];
      for (let l=0;l<maxDepth;l++) layers.push(rows.map(r => r[l]));
      return { rows, layers, maxDepth };
    }
    function groupsFromArray(arr){
      const res=[]; let i=0, n=arr.length;
      while (i<n){
        const v=arr[i]; let j=i+1;
        while (j<n && arr[j]===v) j++;
        res.push({ start:i, end:j-1, label:v });
        i=j;
      }
      return res;
    }
    function computeWeeks(rows){
      const weeks = rows.map(r=> r[r.length-1] || '');
      const uniq = Array.from(new Set(weeks));
      const palette = ['#5470c6','#91cc75','#fac858','#ee6666','#73c0de','#3ba272','#fc8452','#9a60b4','#ea7ccc','#5ab1ef','#9fb6ff'];
      const map = {}; uniq.forEach((w,i) => map[w] = palette[i % palette.length]);
      return { weeks, uniq, map };
    }

    // parse
    const parsed = splitIntoLayers(rawLabels);
    let { rows, layers, maxDepth } = parsed;
    let groupsPerLevel = layers.map(l=> groupsFromArray(l));
    let weekInfo = computeWeeks(rows);

    // UI week controls
    const controlsRoot = document.getElementById('week-checkboxes');
    function buildWeekControls(){
      controlsRoot.innerHTML = '';
      weekInfo.uniq.forEach(w=>{
        const id = 'wk_'+w.replace(/[^\w]/g,'_');
        const label = document.createElement('label');
        label.innerHTML = `<input type="checkbox" checked id="${id}" value="${w}"/><span class="legend-color" style="background:${weekInfo.map[w]}"></span><span style="flex:1">${w}</span>`;
        controlsRoot.appendChild(label);
      });
    }
    buildWeekControls();
    document.getElementById('select-all').addEventListener('click', ()=>{ controlsRoot.querySelectorAll('input').forEach(cb=>cb.checked=true); applyFilterAndRender(); });
    document.getElementById('clear-all').addEventListener('click', ()=>{ controlsRoot.querySelectorAll('input').forEach(cb=>cb.checked=false); applyFilterAndRender(); });
    controlsRoot.addEventListener('change', applyFilterAndRender);

    const chart = echarts.init(document.getElementById('main'));

    function applyFilterAndRender(){
      const selectedWeeks = Array.from(controlsRoot.querySelectorAll('input[type=checkbox]')).filter(cb=>cb.checked).map(cb=>cb.value);
      const indices = rows.map((r,i)=> selectedWeeks.includes(r[r.length-1]) ? i : -1).map((v,i)=> v===-1? null : i).filter(i=>i!==null);

      if (indices.length === 0) {
        chart.clear();
        chart.setOption({ title: { text: '未选择任何周' } });
        return;
      }

      const fLabels = indices.map(i => rawLabels[i]);
      const fRows = indices.map(i => rows[i].slice());
      const fValues = indices.map(i => rawValues[i]);
      fRows.forEach(r=>{ while (r.length < maxDepth) r.push(''); });

      const fLayers = [];
      for (let l=0;l<maxDepth;l++) fLayers.push(fRows.map(r=> r[l]));
      const fGroups = fLayers.map(arr=> groupsFromArray(arr));
      const fWeeks = fRows.map(r => r[r.length-1] || '');
      const seriesData = fValues.map((v,idx)=> ({ value: v, itemStyle: { color: weekInfo.map[fWeeks[idx]] } }));

      // Use a single invisible category axis for positioning, render all labels via graphic
      const categoryAxis = { type:'category', data: fLabels.map((s,i)=> i.toString()), axisLine:{show:false}, axisTick:{show:false}, axisLabel:{show:false} };

      const option = {
        title: { text: '2025年10月各集群AOC故障数（已修复）', left: 'center' },
        grid: { left: baseGrid.left, right: baseGrid.right, top: baseGrid.top, bottom: baseGrid.bottom + maxDepth * gapBetweenAxes },
        tooltip: { trigger:'item', formatter: function(params){ const idx=params.dataIndex; const v = params.value && params.value.value!==undefined ? params.value.value : params.value; return `${fLabels[idx]}<br/>故障数: <b>${v}</b>`; } },
        xAxis: [categoryAxis],
        yAxis: { type:'value', name:'故障数', nameLocation:'end', nameGap:18 },
        series: [{ name:'故障数', type:'bar', data: seriesData, xAxisIndex:0, barMaxWidth:28 }],
        graphic: []
      };

      chart.setOption(option, { notMerge:true, lazyUpdate:false });

      // draw bands & centered text & separators (no duplication with axis labels)
      const w = chart.getWidth(), h = chart.getHeight();
      const left = baseGrid.left, right = baseGrid.right, top = baseGrid.top, bottom = baseGrid.bottom;
      const innerW = w - left - right;
      const n = fLabels.length;
      const catW = n>0? innerW / n : innerW;

      const gfx = [];
      const levelPalettes = [
        ['#F8FBFF','#EEF6FF','#F2FFF7','#FFF8F2'],
        ['#FFF7EC','#FFF0F3','#F7F7FF','#F3FFF9'],
        ['#F8F9FB','#F3F6FF','#FFF6F3','#F7FFF7'],
        ['#F7FBFF','#FFF7FB','#F7FFF7','#FFF7EF']
      ];

      // stack from bottom (week level) up to top (level 0)
      for (let level = maxDepth - 1; level >= 0; level--){
        const groups = fGroups[level];
        const idxFromBottom = (maxDepth - 1) - level; // 0 for week
        const bandTop = h - bottom + idxFromBottom * gapBetweenAxes + 6;
        const bandHeight = gapBetweenAxes - 8;
        const palette = levelPalettes[level % levelPalettes.length];
        let colorIdx = 0;
        groups.forEach(g => {
          if (!g.label) { colorIdx = (colorIdx + 1) % palette.length; return; }
          const x = left + g.start * catW;
          const width = (g.end - g.start + 1) * catW;
          const isWeek = (level === maxDepth - 1);
          if (!isWeek) {
            gfx.push({ type:'rect', z:1, left: x, top: bandTop, shape:{ width: width, height: bandHeight }, style:{ fill: palette[colorIdx%palette.length], stroke:'#e6e6e6', lineWidth:1, opacity:1 }, silent:true });
            gfx.push({ type:'text', z:2, left: x + width/2, top: bandTop + bandHeight/2, style:{ text: g.label, textAlign:'center', textVerticalAlign:'middle', fill:'#222', font:(axisLabelFontSize+1)+'px sans-serif' }, silent:true });
          } else {
            // week level: no text, use color of bars to indicate week
            gfx.push({ type:'rect', z:1, left: x, top: bandTop, shape:{ width: width, height: bandHeight }, style:{ fill:'transparent', stroke:'#f4f4f4', lineWidth:0, opacity:1 }, silent:true });
          }
          // separators
          gfx.push({ type:'line', z:3, shape:{ x1:x, y1:top-6, x2:x, y2: h - bottom + maxDepth*gapBetweenAxes + 12 }, style:{ stroke:'#e0e0e0', lineWidth:1 } });
          gfx.push({ type:'line', z:3, shape:{ x1:x+width, y1:top-6, x2:x+width, y2: h - bottom + maxDepth*gapBetweenAxes + 12 }, style:{ stroke:'#e0e0e0', lineWidth:1 } });
          colorIdx++;
        });
      }

      chart.setOption({ graphic: gfx }, { notMerge:false, lazyUpdate:false });
    }

    // initial render
    applyFilterAndRender();

    // resize handling
    window.addEventListener('resize', function(){ chart.resize(); setTimeout(applyFilterAndRender, 150); });
  }

})();
</script>
</body>
</html>
