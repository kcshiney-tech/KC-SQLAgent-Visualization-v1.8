<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>ECharts 多级 X 轴示例（分组居中显示）</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <style>
    body { font-family: Arial, "Microsoft Yahei", sans-serif; margin: 16px; }
    #main { width: 100%; height: 640px; border: 1px solid #eee; }
    .note { margin-top:8px; color:#666 }
  </style>
</head>
<body>
  <h3>ECharts 多级 X 轴（分组合并并居中显示）</h3>
  <div id="main"></div>
  <div class="note">
    说明：每一层是单独的 xAxis。代码会自动将相邻相同分组合并显示（把文字放在组中点处），支持任意层数。
  </div>

<script>
(function(){
  const rawLabels = [
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-30",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-40",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-41",
    "ROCE-TOR下联-QHDX01.400G_BASE_VR4_QSFP112.TRILIGHT.2025-42",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-39",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-40",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-41",
    "ROCE-TOR下联-QHDX03.400G_AOC_QSFP112.SONT.2025-42",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-39",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-40",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-41",
    "ROCE-TOR下联-QYYD05.400G_BASE_SR4_QSFPDD.TRILIGHT.2025-42",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-39",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-40",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-41",
    "ROCE-TOR下联-QYYD05.AOC_QSFPDD.Crealights.2025-42",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-39",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-40",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-41",
    "ROCE-TOR下联-QYYD06.400G_AOC_QSFP112.SONT.2025-42",
    "ROCE-TOR下联-QYZNJ01.400G_AOC_QSFP112.Crealights.2025-41",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-39",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-40",
    "ROCE-TOR下联-QYZNJ01.400G_BASE_SR4_QSFP112.TRILIGHT.2025-42",
    "ROCE-TOR下联-QYZNJ01.AOC_QSFPDD.Crealights.2025-40"
  ];

  const values = [0,0,2,0,1,1,0,0,0,3,0,0,7,0,0,0,4,1,1,1,1,2,3,1,1];

  // ---------- helper: split each raw label into layers ----------
  // Treat first '-' as separator between cluster and model (so convert first '-' -> '.'),
  // then split by '.' to get hierarchical parts.
  function splitIntoLayers(s){
    const idx = s.indexOf('-');
    let t = s;
    if (idx > 0) {
      // replace only first '-' between cluster and model with '.' to unify separator
      t = s.slice(0, idx) + '.' + s.slice(idx+1);
    }
    const parts = t.split('.');
    return parts; // array, e.g. [cluster, model, moduleType, vendor, week]
  }

  const layersArr = rawLabels.map(splitIntoLayers);
  // compute max depth (some labels might be shorter)
  const maxDepth = Math.max(...layersArr.map(a=>a.length));

  // pad arrays to same depth (pad with empty string at end)
  for (let i=0;i<layersArr.length;i++){
    while (layersArr[i].length < maxDepth) layersArr[i].push('');
  }

  // layers[level] will be array of length N of that level's labels
  const layers = [];
  for (let level=0; level<maxDepth; level++){
    layers.push(layersArr.map(a => a[level]));
  }

  // ---------- helper: for each level, compute label-at-midpoint array ----------
  // For a given arr of values (length N), we find contiguous ranges with same value,
  // and create an output array of length N with empty strings except the midpoint index set to the group's label.
  function computeMidLabels(arr){
    const n = arr.length;
    const out = new Array(n).fill('');
    let i = 0;
    while (i < n){
      const v = arr[i];
      let j = i+1;
      while (j < n && arr[j] === v) j++;
      // group is [i, j-1]; choose midpoint
      const mid = Math.floor((i + j - 1) / 2);
      out[mid] = v || ''; // show label only at midpoint
      i = j;
    }
    return out;
  }

  const midLabelsPerLevel = layers.map(levelArr => computeMidLabels(levelArr));

  // ---------- build multiple xAxes, stacked upward using offset ----------
  // We'll create one xAxis per level. Bottom-most (index = maxDepth-1) will be the real category axis with full labels (optionally shortened).
  const xAxes = [];
  const axisLabelFontSize = 11;
  const baseOffset = 8; // bottom offset for bottom-most axis
  const gapBetweenAxes = 22; // vertical gap between axis label rows
  // Determine offsets from bottom: bottom-most offset=0, next = (font+gap), etc.
  for (let level = 0; level < maxDepth; level++){
    const idxFromBottom = (maxDepth - 1) - level; // 0 means bottom-most
    const offset = baseOffset + idxFromBottom * gapBetweenAxes;
    const showTicks = (level === maxDepth - 1); // only show ticks for bottom-most (detailed)
    const isBottom = (level === maxDepth - 1);

    // For label content:
    const labelData = (level === maxDepth - 1)
      ? rawLabels.map(s => { // bottom-most, show short form (e.g., week or last segment) — we take last part
          const parts = s.split('.');
          return parts[parts.length - 1]; // show week like '2025-30'
        })
      : midLabelsPerLevel[level]; // show mid labels for higher levels (mostly blanks except midpoints)

    xAxes.push({
      type: 'category',
      position: 'bottom',
      offset: offset,
      data: labelData,
      axisLine: { show: false },
      axisTick: { show: showTicks, alignWithLabel: true, length: showTicks ? 6 : 0 },
      splitLine: { show: false },
      axisLabel: {
        // show empty labels as blank; center align at tick
        interval: 0,
        formatter: function (val) {
          // if val is empty, return '' so nothing drawn
          // for bottom-most we may want to wrap long labels
          if (!val) return '';
          if (isBottom) {
            return val; // already short
          } else {
            // allow wrapping for long names: split by '-' or '_' or space
            const s = val;
            // try to shorten cluster-model like "ROCE-TOR下联QHDX01" into two lines if too long
            if (s.length > 16) {
              return s.slice(0, 16) + '\n' + s.slice(16);
            }
            return s;
          }
        },
        fontSize: axisLabelFontSize,
        align: 'center'
      },
      // prevent label overlap by forcing all shown but many are empty
      axisPointer: { show: false }
    });
  }

  // series uses category index positions; tooltip should show original full label if needed
  const option = {
    title: { text: '2025年10月各集群AOC故障数按型号、厂商、周分布', left: 'center' },
    tooltip: {
      trigger: 'axis',
      axisPointer: { type: 'shadow' },
      formatter: function(params){
        // params[0] corresponds to series data at index
        if (!params || !params.length) return '';
        const p = params[0];
        const idx = p.dataIndex;
        return rawLabels[idx] + '<br/>' + p.seriesName + ': ' + p.data;
      }
    },
    grid: {
      left: 60,
      right: 30,
      top: 80,
      bottom: 20 + maxDepth * gapBetweenAxes // allow room for stacked axes
    },
    xAxis: xAxes,
    yAxis: {
      type: 'value',
      name: '故障数'
    },
    series: [{
      name: '故障数',
      type: 'bar',
      data: values,
      barMaxWidth: 24,
      itemStyle: { color: '#5470c6' }
    }]
  };

  const chart = echarts.init(document.getElementById('main'));
  chart.setOption(option);

  // responsive resize
  window.addEventListener('resize', function(){ chart.resize(); });

  // debug: print arrays
  console.log('layers:', layers);
  console.log('midLabelsPerLevel:', midLabelsPerLevel);
})();
</script>
</body>
</html>
